{
    "name": "upstash",
    "displayName": "Upstash",
    "description": "A Pulumi package for creating and managing upstash cloud resources.",
    "keywords": [
        "pulumi",
        "upstash",
        "category/cloud"
    ],
    "homepage": "https://www.upstash.com",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`upstash` Terraform Provider](https://github.com/upstash/terraform-provider-upstash).",
    "repository": "https://github.com/upstash/pulumi-upstash",
    "logoUrl": "https://upstash.com/static/logo/logo-light.svg",
    "pluginDownloadURL": "github://api.github.com/upstash/pulumi-upstash",
    "publisher": "Upstash",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "config": {
        "variables": {
            "apiKey": {
                "type": "string"
            },
            "email": {
                "type": "string"
            }
        },
        "defaults": [
            "apiKey",
            "email"
        ]
    },
    "provider": {
        "description": "The provider type for the upstash package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "apiKey": {
                "type": "string"
            },
            "email": {
                "type": "string"
            }
        },
        "required": [
            "apiKey",
            "email"
        ],
        "inputProperties": {
            "apiKey": {
                "type": "string"
            },
            "email": {
                "type": "string"
            }
        },
        "requiredInputs": [
            "apiKey",
            "email"
        ]
    },
    "resources": {
        "upstash:index/kafkaCluster:KafkaCluster": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upstash from \"@pulumi/upstash\";\n\nconst exampleCluster = new upstash.KafkaCluster(\"exampleCluster\", {\n    clusterName: \"TerraformCluster\",\n    multizone: false,\n    region: \"eu-west-1\",\n});\n```\n```python\nimport pulumi\nimport upstash_pulumi as upstash\n\nexample_cluster = upstash.KafkaCluster(\"exampleCluster\",\n    cluster_name=\"TerraformCluster\",\n    multizone=False,\n    region=\"eu-west-1\")\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleCluster = new Upstash.KafkaCluster(\"exampleCluster\", new Upstash.KafkaClusterArgs\n        {\n            ClusterName = \"TerraformCluster\",\n            Multizone = false,\n            Region = \"eu-west-1\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upstash.NewKafkaCluster(ctx, \"exampleCluster\", \u0026upstash.KafkaClusterArgs{\n\t\t\tClusterName: pulumi.String(\"TerraformCluster\"),\n\t\t\tMultizone:   pulumi.Bool(false),\n\t\t\tRegion:      pulumi.String(\"eu-west-1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleCluster = new KafkaCluster(\"exampleCluster\", KafkaClusterArgs.builder()        \n            .clusterName(\"TerraformCluster\")\n            .multizone(false)\n            .region(\"eu-west-1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleCluster:\n    type: upstash:KafkaCluster\n    properties:\n      clusterName: TerraformCluster\n      multizone: false\n      region: eu-west-1\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "clusterId": {
                    "type": "string",
                    "description": "Unique Cluster ID for created cluster\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "Name of the cluster\n"
                },
                "creationTime": {
                    "type": "integer",
                    "description": "Creation time of the cluster\n"
                },
                "maxMessageSize": {
                    "type": "integer",
                    "description": "Max Message Size for the cluster\n"
                },
                "maxMessagesPerSecond": {
                    "type": "integer",
                    "description": "Max Messages Per Second for the cluster\n"
                },
                "maxPartitions": {
                    "type": "integer",
                    "description": "Max Partitions for the cluster\n"
                },
                "maxRetentionSize": {
                    "type": "integer",
                    "description": "Max Retention Size of the cluster\n"
                },
                "maxRetentionTime": {
                    "type": "integer",
                    "description": "Max Retention Time of the cluster\n"
                },
                "multizone": {
                    "type": "boolean",
                    "description": "Whether cluster has multizone attribute\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for the cluster\n"
                },
                "region": {
                    "type": "string",
                    "description": "region of the cluster. Possible values (may change) are: \"eu-west-1\", \"us-east-1\"\n"
                },
                "restEndpoint": {
                    "type": "string",
                    "description": "REST Endpoint of the cluster\n"
                },
                "state": {
                    "type": "string",
                    "description": "State, where the cluster is originated\n"
                },
                "tcpEndpoint": {
                    "type": "string",
                    "description": "TCP Endpoint of the cluster\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the cluster\n"
                },
                "username": {
                    "type": "string",
                    "description": "Base64 encoded username for the cluster\n"
                }
            },
            "required": [
                "clusterId",
                "clusterName",
                "creationTime",
                "maxMessageSize",
                "maxMessagesPerSecond",
                "maxPartitions",
                "maxRetentionSize",
                "maxRetentionTime",
                "password",
                "region",
                "restEndpoint",
                "state",
                "tcpEndpoint",
                "type",
                "username"
            ],
            "inputProperties": {
                "clusterName": {
                    "type": "string",
                    "description": "Name of the cluster\n"
                },
                "multizone": {
                    "type": "boolean",
                    "description": "Whether cluster has multizone attribute\n",
                    "willReplaceOnChanges": true
                },
                "region": {
                    "type": "string",
                    "description": "region of the cluster. Possible values (may change) are: \"eu-west-1\", \"us-east-1\"\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clusterName",
                "region"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering KafkaCluster resources.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "Unique Cluster ID for created cluster\n"
                    },
                    "clusterName": {
                        "type": "string",
                        "description": "Name of the cluster\n"
                    },
                    "creationTime": {
                        "type": "integer",
                        "description": "Creation time of the cluster\n"
                    },
                    "maxMessageSize": {
                        "type": "integer",
                        "description": "Max Message Size for the cluster\n"
                    },
                    "maxMessagesPerSecond": {
                        "type": "integer",
                        "description": "Max Messages Per Second for the cluster\n"
                    },
                    "maxPartitions": {
                        "type": "integer",
                        "description": "Max Partitions for the cluster\n"
                    },
                    "maxRetentionSize": {
                        "type": "integer",
                        "description": "Max Retention Size of the cluster\n"
                    },
                    "maxRetentionTime": {
                        "type": "integer",
                        "description": "Max Retention Time of the cluster\n"
                    },
                    "multizone": {
                        "type": "boolean",
                        "description": "Whether cluster has multizone attribute\n",
                        "willReplaceOnChanges": true
                    },
                    "password": {
                        "type": "string",
                        "description": "Password for the cluster\n"
                    },
                    "region": {
                        "type": "string",
                        "description": "region of the cluster. Possible values (may change) are: \"eu-west-1\", \"us-east-1\"\n",
                        "willReplaceOnChanges": true
                    },
                    "restEndpoint": {
                        "type": "string",
                        "description": "REST Endpoint of the cluster\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "State, where the cluster is originated\n"
                    },
                    "tcpEndpoint": {
                        "type": "string",
                        "description": "TCP Endpoint of the cluster\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the cluster\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Base64 encoded username for the cluster\n"
                    }
                },
                "type": "object"
            }
        },
        "upstash:index/kafkaConnector:KafkaConnector": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as pulumi from \"@upstash/pulumi\";\n\n// Not necessary if the topic belongs to an already created cluster.\nconst exampleKafkaCluster = new upstash.KafkaCluster(\"exampleKafkaCluster\", {\n    clusterName: \"Terraform_Upstash_Cluster\",\n    region: \"eu-west-1\",\n    multizone: false,\n});\nconst exampleKafkaTopic = new upstash.KafkaTopic(\"exampleKafkaTopic\", {\n    topicName: \"TerraformTopic\",\n    partitions: 1,\n    retentionTime: 625135,\n    retentionSize: 725124,\n    maxMessageSize: 829213,\n    cleanupPolicy: \"delete\",\n    clusterId: resource.upstash_kafka_cluster.exampleKafkaCluster.cluster_id,\n});\nconst exampleKafkaConnector = new upstash.KafkaConnector(\"exampleKafkaConnector\", {\n    clusterId: exampleKafkaCluster.clusterId,\n    properties: {\n        collection: \"user123\",\n        \"connection.uri\": \"mongodb+srv://test:test@cluster0.fohyg7p.mongodb.net/?retryWrites=true\u0026w=majority\",\n        \"connector.class\": \"com.mongodb.kafka.connect.MongoSourceConnector\",\n        database: \"myshinynewdb2\",\n        topics: exampleKafkaTopic.topicName,\n    },\n});\n// OPTIONAL: change between restart-running-paused\n// running_state = \"running\"\n```\n```python\nimport pulumi\nimport upstash_pulumi as upstash\n\n# Not necessary if the topic belongs to an already created cluster.\nexample_kafka_cluster = upstash.KafkaCluster(\"exampleKafkaCluster\",\n    cluster_name=\"Terraform_Upstash_Cluster\",\n    region=\"eu-west-1\",\n    multizone=False)\nexample_kafka_topic = upstash.KafkaTopic(\"exampleKafkaTopic\",\n    topic_name=\"TerraformTopic\",\n    partitions=1,\n    retention_time=625135,\n    retention_size=725124,\n    max_message_size=829213,\n    cleanup_policy=\"delete\",\n    cluster_id=resource[\"upstash_kafka_cluster\"][\"exampleKafkaCluster\"][\"cluster_id\"])\nexample_kafka_connector = upstash.KafkaConnector(\"exampleKafkaConnector\",\n    cluster_id=example_kafka_cluster.cluster_id,\n    properties={\n        \"collection\": \"user123\",\n        \"connection.uri\": \"mongodb+srv://test:test@cluster0.fohyg7p.mongodb.net/?retryWrites=true\u0026w=majority\",\n        \"connector.class\": \"com.mongodb.kafka.connect.MongoSourceConnector\",\n        \"database\": \"myshinynewdb2\",\n        \"topics\": example_kafka_topic.topic_name,\n    })\n# OPTIONAL: change between restart-running-paused\n# running_state = \"running\"\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Not necessary if the topic belongs to an already created cluster.\n        var exampleKafkaCluster = new Upstash.KafkaCluster(\"exampleKafkaCluster\", new Upstash.KafkaClusterArgs\n        {\n            ClusterName = \"Terraform_Upstash_Cluster\",\n            Region = \"eu-west-1\",\n            Multizone = false,\n        });\n        var exampleKafkaTopic = new Upstash.KafkaTopic(\"exampleKafkaTopic\", new Upstash.KafkaTopicArgs\n        {\n            TopicName = \"TerraformTopic\",\n            Partitions = 1,\n            RetentionTime = 625135,\n            RetentionSize = 725124,\n            MaxMessageSize = 829213,\n            CleanupPolicy = \"delete\",\n            ClusterId = resource.Upstash_kafka_cluster.ExampleKafkaCluster.Cluster_id,\n        });\n        var exampleKafkaConnector = new Upstash.KafkaConnector(\"exampleKafkaConnector\", new Upstash.KafkaConnectorArgs\n        {\n            ClusterId = exampleKafkaCluster.ClusterId,\n            Properties = \n            {\n                { \"collection\", \"user123\" },\n                { \"connection.uri\", \"mongodb+srv://test:test@cluster0.fohyg7p.mongodb.net/?retryWrites=true\u0026w=majority\" },\n                { \"connector.class\", \"com.mongodb.kafka.connect.MongoSourceConnector\" },\n                { \"database\", \"myshinynewdb2\" },\n                { \"topics\", exampleKafkaTopic.TopicName },\n            },\n        });\n        // OPTIONAL: change between restart-running-paused\n        // running_state = \"running\"\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleKafkaCluster, err := upstash.NewKafkaCluster(ctx, \"exampleKafkaCluster\", \u0026upstash.KafkaClusterArgs{\n\t\t\tClusterName: pulumi.String(\"Terraform_Upstash_Cluster\"),\n\t\t\tRegion:      pulumi.String(\"eu-west-1\"),\n\t\t\tMultizone:   pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleKafkaTopic, err := upstash.NewKafkaTopic(ctx, \"exampleKafkaTopic\", \u0026upstash.KafkaTopicArgs{\n\t\t\tTopicName:      pulumi.String(\"TerraformTopic\"),\n\t\t\tPartitions:     pulumi.Int(1),\n\t\t\tRetentionTime:  pulumi.Int(625135),\n\t\t\tRetentionSize:  pulumi.Int(725124),\n\t\t\tMaxMessageSize: pulumi.Int(829213),\n\t\t\tCleanupPolicy:  pulumi.String(\"delete\"),\n\t\t\tClusterId:      pulumi.Any(resource.Upstash_kafka_cluster.ExampleKafkaCluster.Cluster_id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upstash.NewKafkaConnector(ctx, \"exampleKafkaConnector\", \u0026upstash.KafkaConnectorArgs{\n\t\t\tClusterId: exampleKafkaCluster.ClusterId,\n\t\t\tProperties: pulumi.AnyMap{\n\t\t\t\t\"collection\":      pulumi.Any(\"user123\"),\n\t\t\t\t\"connection.uri\":  pulumi.Any(\"mongodb+srv://test:test@cluster0.fohyg7p.mongodb.net/?retryWrites=true\u0026w=majority\"),\n\t\t\t\t\"connector.class\": pulumi.Any(\"com.mongodb.kafka.connect.MongoSourceConnector\"),\n\t\t\t\t\"database\":        pulumi.Any(\"myshinynewdb2\"),\n\t\t\t\t\"topics\":          exampleKafkaTopic.TopicName,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleKafkaCluster = new KafkaCluster(\"exampleKafkaCluster\", KafkaClusterArgs.builder()        \n            .clusterName(\"Terraform_Upstash_Cluster\")\n            .region(\"eu-west-1\")\n            .multizone(false)\n            .build());\n\n        var exampleKafkaTopic = new KafkaTopic(\"exampleKafkaTopic\", KafkaTopicArgs.builder()        \n            .topicName(\"TerraformTopic\")\n            .partitions(1)\n            .retentionTime(625135)\n            .retentionSize(725124)\n            .maxMessageSize(829213)\n            .cleanupPolicy(\"delete\")\n            .clusterId(resource.upstash_kafka_cluster().exampleKafkaCluster().cluster_id())\n            .build());\n\n        var exampleKafkaConnector = new KafkaConnector(\"exampleKafkaConnector\", KafkaConnectorArgs.builder()        \n            .clusterId(exampleKafkaCluster.clusterId())\n            .properties(Map.ofEntries(\n                Map.entry(\"collection\", \"user123\"),\n                Map.entry(\"connection.uri\", \"mongodb+srv://test:test@cluster0.fohyg7p.mongodb.net/?retryWrites=true\u0026w=majority\"),\n                Map.entry(\"connector.class\", \"com.mongodb.kafka.connect.MongoSourceConnector\"),\n                Map.entry(\"database\", \"myshinynewdb2\"),\n                Map.entry(\"topics\", exampleKafkaTopic.topicName())\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleKafkaCluster:\n    type: upstash:KafkaCluster\n    properties:\n      clusterName: Terraform_Upstash_Cluster\n      region: eu-west-1\n      multizone: false\n  exampleKafkaTopic:\n    type: upstash:KafkaTopic\n    properties:\n      topicName: TerraformTopic\n      partitions: 1\n      retentionTime: 625135\n      retentionSize: 725124\n      maxMessageSize: 829213\n      cleanupPolicy: delete\n      clusterId: ${resource.upstash_kafka_cluster.exampleKafkaCluster.cluster_id}\n  exampleKafkaConnector:\n    type: upstash:KafkaConnector\n    properties:\n      clusterId: ${exampleKafkaCluster.clusterId}\n      properties:\n        collection: user123\n        connection.uri: mongodb+srv://test:test@cluster0.fohyg7p.mongodb.net/?retryWrites=true\u0026w=majority\n        connector.class: com.mongodb.kafka.connect.MongoSourceConnector\n        database: myshinynewdb2\n        topics: ${exampleKafkaTopic.topicName}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "clusterId": {
                    "type": "string",
                    "description": "Name of the connector\n"
                },
                "connectorId": {
                    "type": "string",
                    "description": "Unique Connector ID for created connector\n"
                },
                "creationTime": {
                    "type": "integer",
                    "description": "Creation of the connector\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the connector\n"
                },
                "properties": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Properties that the connector will have\n"
                },
                "runningState": {
                    "type": "string",
                    "description": "Running state of the connector. Can be either 'paused', 'running' or 'restart'\n"
                }
            },
            "required": [
                "clusterId",
                "connectorId",
                "creationTime",
                "name",
                "properties"
            ],
            "inputProperties": {
                "clusterId": {
                    "type": "string",
                    "description": "Name of the connector\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Name of the connector\n",
                    "willReplaceOnChanges": true
                },
                "properties": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Properties that the connector will have\n"
                },
                "runningState": {
                    "type": "string",
                    "description": "Running state of the connector. Can be either 'paused', 'running' or 'restart'\n"
                }
            },
            "requiredInputs": [
                "clusterId",
                "properties"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering KafkaConnector resources.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "Name of the connector\n",
                        "willReplaceOnChanges": true
                    },
                    "connectorId": {
                        "type": "string",
                        "description": "Unique Connector ID for created connector\n"
                    },
                    "creationTime": {
                        "type": "integer",
                        "description": "Creation of the connector\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the connector\n",
                        "willReplaceOnChanges": true
                    },
                    "properties": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Properties that the connector will have\n"
                    },
                    "runningState": {
                        "type": "string",
                        "description": "Running state of the connector. Can be either 'paused', 'running' or 'restart'\n"
                    }
                },
                "type": "object"
            }
        },
        "upstash:index/kafkaCredential:KafkaCredential": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as pulumi from \"@upstash/pulumi\";\n\nconst exampleKafkaCluster = new upstash.KafkaCluster(\"exampleKafkaCluster\", {\n    clusterName: _var.cluster_name,\n    region: _var.region,\n    multizone: _var.multizone,\n});\nconst exampleKafkaTopic = new upstash.KafkaTopic(\"exampleKafkaTopic\", {\n    topicName: _var.topic_name,\n    partitions: _var.partitions,\n    retentionTime: _var.retention_time,\n    retentionSize: _var.retention_size,\n    maxMessageSize: _var.max_message_size,\n    cleanupPolicy: _var.cleanup_policy,\n    clusterId: resource.upstash_kafka_cluster.exampleKafkaCluster.cluster_id,\n});\nconst exampleKafkaCredential = new upstash.KafkaCredential(\"exampleKafkaCredential\", {\n    clusterId: exampleKafkaCluster.clusterId,\n    credentialName: \"credentialFromTerraform\",\n    topic: exampleKafkaTopic.topicName,\n    permissions: \"ALL\",\n});\nconst exampleKafkaCredentialAllTopics = new upstash.KafkaCredential(\"exampleKafkaCredentialAllTopics\", {\n    clusterId: exampleKafkaCluster.clusterId,\n    credentialName: \"credentialFromTerraform\",\n    topic: \"*\",\n    permissions: \"ALL\",\n});\n```\n```python\nimport pulumi\nimport upstash_pulumi as upstash\n\nexample_kafka_cluster = upstash.KafkaCluster(\"exampleKafkaCluster\",\n    cluster_name=var[\"cluster_name\"],\n    region=var[\"region\"],\n    multizone=var[\"multizone\"])\nexample_kafka_topic = upstash.KafkaTopic(\"exampleKafkaTopic\",\n    topic_name=var[\"topic_name\"],\n    partitions=var[\"partitions\"],\n    retention_time=var[\"retention_time\"],\n    retention_size=var[\"retention_size\"],\n    max_message_size=var[\"max_message_size\"],\n    cleanup_policy=var[\"cleanup_policy\"],\n    cluster_id=resource[\"upstash_kafka_cluster\"][\"exampleKafkaCluster\"][\"cluster_id\"])\nexample_kafka_credential = upstash.KafkaCredential(\"exampleKafkaCredential\",\n    cluster_id=example_kafka_cluster.cluster_id,\n    credential_name=\"credentialFromTerraform\",\n    topic=example_kafka_topic.topic_name,\n    permissions=\"ALL\")\nexample_kafka_credential_all_topics = upstash.KafkaCredential(\"exampleKafkaCredentialAllTopics\",\n    cluster_id=example_kafka_cluster.cluster_id,\n    credential_name=\"credentialFromTerraform\",\n    topic=\"*\",\n    permissions=\"ALL\")\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleKafkaCluster = new Upstash.KafkaCluster(\"exampleKafkaCluster\", new Upstash.KafkaClusterArgs\n        {\n            ClusterName = @var.Cluster_name,\n            Region = @var.Region,\n            Multizone = @var.Multizone,\n        });\n        var exampleKafkaTopic = new Upstash.KafkaTopic(\"exampleKafkaTopic\", new Upstash.KafkaTopicArgs\n        {\n            TopicName = @var.Topic_name,\n            Partitions = @var.Partitions,\n            RetentionTime = @var.Retention_time,\n            RetentionSize = @var.Retention_size,\n            MaxMessageSize = @var.Max_message_size,\n            CleanupPolicy = @var.Cleanup_policy,\n            ClusterId = resource.Upstash_kafka_cluster.ExampleKafkaCluster.Cluster_id,\n        });\n        var exampleKafkaCredential = new Upstash.KafkaCredential(\"exampleKafkaCredential\", new Upstash.KafkaCredentialArgs\n        {\n            ClusterId = exampleKafkaCluster.ClusterId,\n            CredentialName = \"credentialFromTerraform\",\n            Topic = exampleKafkaTopic.TopicName,\n            Permissions = \"ALL\",\n        });\n        var exampleKafkaCredentialAllTopics = new Upstash.KafkaCredential(\"exampleKafkaCredentialAllTopics\", new Upstash.KafkaCredentialArgs\n        {\n            ClusterId = exampleKafkaCluster.ClusterId,\n            CredentialName = \"credentialFromTerraform\",\n            Topic = \"*\",\n            Permissions = \"ALL\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleKafkaCluster, err := upstash.NewKafkaCluster(ctx, \"exampleKafkaCluster\", \u0026upstash.KafkaClusterArgs{\n\t\t\tClusterName: pulumi.Any(_var.Cluster_name),\n\t\t\tRegion:      pulumi.Any(_var.Region),\n\t\t\tMultizone:   pulumi.Any(_var.Multizone),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleKafkaTopic, err := upstash.NewKafkaTopic(ctx, \"exampleKafkaTopic\", \u0026upstash.KafkaTopicArgs{\n\t\t\tTopicName:      pulumi.Any(_var.Topic_name),\n\t\t\tPartitions:     pulumi.Any(_var.Partitions),\n\t\t\tRetentionTime:  pulumi.Any(_var.Retention_time),\n\t\t\tRetentionSize:  pulumi.Any(_var.Retention_size),\n\t\t\tMaxMessageSize: pulumi.Any(_var.Max_message_size),\n\t\t\tCleanupPolicy:  pulumi.Any(_var.Cleanup_policy),\n\t\t\tClusterId:      pulumi.Any(resource.Upstash_kafka_cluster.ExampleKafkaCluster.Cluster_id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upstash.NewKafkaCredential(ctx, \"exampleKafkaCredential\", \u0026upstash.KafkaCredentialArgs{\n\t\t\tClusterId:      exampleKafkaCluster.ClusterId,\n\t\t\tCredentialName: pulumi.String(\"credentialFromTerraform\"),\n\t\t\tTopic:          exampleKafkaTopic.TopicName,\n\t\t\tPermissions:    pulumi.String(\"ALL\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upstash.NewKafkaCredential(ctx, \"exampleKafkaCredentialAllTopics\", \u0026upstash.KafkaCredentialArgs{\n\t\t\tClusterId:      exampleKafkaCluster.ClusterId,\n\t\t\tCredentialName: pulumi.String(\"credentialFromTerraform\"),\n\t\t\tTopic:          pulumi.String(\"*\"),\n\t\t\tPermissions:    pulumi.String(\"ALL\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleKafkaCluster = new KafkaCluster(\"exampleKafkaCluster\", KafkaClusterArgs.builder()        \n            .clusterName(var_.cluster_name())\n            .region(var_.region())\n            .multizone(var_.multizone())\n            .build());\n\n        var exampleKafkaTopic = new KafkaTopic(\"exampleKafkaTopic\", KafkaTopicArgs.builder()        \n            .topicName(var_.topic_name())\n            .partitions(var_.partitions())\n            .retentionTime(var_.retention_time())\n            .retentionSize(var_.retention_size())\n            .maxMessageSize(var_.max_message_size())\n            .cleanupPolicy(var_.cleanup_policy())\n            .clusterId(resource.upstash_kafka_cluster().exampleKafkaCluster().cluster_id())\n            .build());\n\n        var exampleKafkaCredential = new KafkaCredential(\"exampleKafkaCredential\", KafkaCredentialArgs.builder()        \n            .clusterId(exampleKafkaCluster.clusterId())\n            .credentialName(\"credentialFromTerraform\")\n            .topic(exampleKafkaTopic.topicName())\n            .permissions(\"ALL\")\n            .build());\n\n        var exampleKafkaCredentialAllTopics = new KafkaCredential(\"exampleKafkaCredentialAllTopics\", KafkaCredentialArgs.builder()        \n            .clusterId(exampleKafkaCluster.clusterId())\n            .credentialName(\"credentialFromTerraform\")\n            .topic(\"*\")\n            .permissions(\"ALL\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleKafkaCluster:\n    type: upstash:KafkaCluster\n    properties:\n      clusterName: ${var.cluster_name}\n      region: ${var.region}\n      multizone: ${var.multizone}\n  exampleKafkaTopic:\n    type: upstash:KafkaTopic\n    properties:\n      topicName: ${var.topic_name}\n      partitions: ${var.partitions}\n      retentionTime: ${var.retention_time}\n      retentionSize: ${var.retention_size}\n      maxMessageSize: ${var.max_message_size}\n      cleanupPolicy: ${var.cleanup_policy}\n      clusterId: ${resource.upstash_kafka_cluster.exampleKafkaCluster.cluster_id}\n  exampleKafkaCredential:\n    type: upstash:KafkaCredential\n    properties:\n      clusterId: ${exampleKafkaCluster.clusterId}\n      credentialName: credentialFromTerraform\n      topic: ${exampleKafkaTopic.topicName}\n      permissions: ALL\n  exampleKafkaCredentialAllTopics:\n    type: upstash:KafkaCredential\n    properties:\n      clusterId: ${exampleKafkaCluster.clusterId}\n      credentialName: credentialFromTerraform\n      topic: '*'\n      permissions: ALL\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "clusterId": {
                    "type": "string",
                    "description": "ID of the kafka cluster\n"
                },
                "creationTime": {
                    "type": "integer",
                    "description": "Creation time of the credential\n"
                },
                "credentialId": {
                    "type": "string",
                    "description": "Unique ID of the kafka credential\n"
                },
                "credentialName": {
                    "type": "string",
                    "description": "Name of the kafka credential\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password to be used in authenticating to the cluster\n"
                },
                "permissions": {
                    "type": "string",
                    "description": "Permission scope given to the kafka credential\n"
                },
                "state": {
                    "type": "string",
                    "description": "State of the credential(active or deleted)\n"
                },
                "topic": {
                    "type": "string",
                    "description": "Name of the kafka topic\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username to be used for the kafka credential\n"
                }
            },
            "required": [
                "clusterId",
                "creationTime",
                "credentialId",
                "credentialName",
                "password",
                "permissions",
                "state",
                "topic",
                "username"
            ],
            "inputProperties": {
                "clusterId": {
                    "type": "string",
                    "description": "ID of the kafka cluster\n",
                    "willReplaceOnChanges": true
                },
                "credentialName": {
                    "type": "string",
                    "description": "Name of the kafka credential\n",
                    "willReplaceOnChanges": true
                },
                "permissions": {
                    "type": "string",
                    "description": "Permission scope given to the kafka credential\n",
                    "willReplaceOnChanges": true
                },
                "topic": {
                    "type": "string",
                    "description": "Name of the kafka topic\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clusterId",
                "credentialName",
                "permissions",
                "topic"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering KafkaCredential resources.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "ID of the kafka cluster\n",
                        "willReplaceOnChanges": true
                    },
                    "creationTime": {
                        "type": "integer",
                        "description": "Creation time of the credential\n"
                    },
                    "credentialId": {
                        "type": "string",
                        "description": "Unique ID of the kafka credential\n"
                    },
                    "credentialName": {
                        "type": "string",
                        "description": "Name of the kafka credential\n",
                        "willReplaceOnChanges": true
                    },
                    "password": {
                        "type": "string",
                        "description": "Password to be used in authenticating to the cluster\n"
                    },
                    "permissions": {
                        "type": "string",
                        "description": "Permission scope given to the kafka credential\n",
                        "willReplaceOnChanges": true
                    },
                    "state": {
                        "type": "string",
                        "description": "State of the credential(active or deleted)\n"
                    },
                    "topic": {
                        "type": "string",
                        "description": "Name of the kafka topic\n",
                        "willReplaceOnChanges": true
                    },
                    "username": {
                        "type": "string",
                        "description": "Username to be used for the kafka credential\n"
                    }
                },
                "type": "object"
            }
        },
        "upstash:index/kafkaTopic:KafkaTopic": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as pulumi from \"@upstash/pulumi\";\n\n// Not necessary if the topic belongs to an already created cluster.\nconst exampleKafkaCluster = new upstash.KafkaCluster(\"exampleKafkaCluster\", {\n    clusterName: \"Terraform_Upstash_Cluster\",\n    region: \"eu-west-1\",\n    multizone: false,\n});\nconst exampleKafkaTopic = new upstash.KafkaTopic(\"exampleKafkaTopic\", {\n    topicName: \"TerraformTopic\",\n    partitions: 1,\n    retentionTime: 625135,\n    retentionSize: 725124,\n    maxMessageSize: 829213,\n    cleanupPolicy: \"delete\",\n    clusterId: resource.upstash_kafka_cluster.exampleKafkaCluster.cluster_id,\n});\n```\n```python\nimport pulumi\nimport upstash_pulumi as upstash\n\n# Not necessary if the topic belongs to an already created cluster.\nexample_kafka_cluster = upstash.KafkaCluster(\"exampleKafkaCluster\",\n    cluster_name=\"Terraform_Upstash_Cluster\",\n    region=\"eu-west-1\",\n    multizone=False)\nexample_kafka_topic = upstash.KafkaTopic(\"exampleKafkaTopic\",\n    topic_name=\"TerraformTopic\",\n    partitions=1,\n    retention_time=625135,\n    retention_size=725124,\n    max_message_size=829213,\n    cleanup_policy=\"delete\",\n    cluster_id=resource[\"upstash_kafka_cluster\"][\"exampleKafkaCluster\"][\"cluster_id\"])\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Not necessary if the topic belongs to an already created cluster.\n        var exampleKafkaCluster = new Upstash.KafkaCluster(\"exampleKafkaCluster\", new Upstash.KafkaClusterArgs\n        {\n            ClusterName = \"Terraform_Upstash_Cluster\",\n            Region = \"eu-west-1\",\n            Multizone = false,\n        });\n        var exampleKafkaTopic = new Upstash.KafkaTopic(\"exampleKafkaTopic\", new Upstash.KafkaTopicArgs\n        {\n            TopicName = \"TerraformTopic\",\n            Partitions = 1,\n            RetentionTime = 625135,\n            RetentionSize = 725124,\n            MaxMessageSize = 829213,\n            CleanupPolicy = \"delete\",\n            ClusterId = resource.Upstash_kafka_cluster.ExampleKafkaCluster.Cluster_id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upstash.NewKafkaCluster(ctx, \"exampleKafkaCluster\", \u0026upstash.KafkaClusterArgs{\n\t\t\tClusterName: pulumi.String(\"Terraform_Upstash_Cluster\"),\n\t\t\tRegion:      pulumi.String(\"eu-west-1\"),\n\t\t\tMultizone:   pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upstash.NewKafkaTopic(ctx, \"exampleKafkaTopic\", \u0026upstash.KafkaTopicArgs{\n\t\t\tTopicName:      pulumi.String(\"TerraformTopic\"),\n\t\t\tPartitions:     pulumi.Int(1),\n\t\t\tRetentionTime:  pulumi.Int(625135),\n\t\t\tRetentionSize:  pulumi.Int(725124),\n\t\t\tMaxMessageSize: pulumi.Int(829213),\n\t\t\tCleanupPolicy:  pulumi.String(\"delete\"),\n\t\t\tClusterId:      pulumi.Any(resource.Upstash_kafka_cluster.ExampleKafkaCluster.Cluster_id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleKafkaCluster = new KafkaCluster(\"exampleKafkaCluster\", KafkaClusterArgs.builder()        \n            .clusterName(\"Terraform_Upstash_Cluster\")\n            .region(\"eu-west-1\")\n            .multizone(false)\n            .build());\n\n        var exampleKafkaTopic = new KafkaTopic(\"exampleKafkaTopic\", KafkaTopicArgs.builder()        \n            .topicName(\"TerraformTopic\")\n            .partitions(1)\n            .retentionTime(625135)\n            .retentionSize(725124)\n            .maxMessageSize(829213)\n            .cleanupPolicy(\"delete\")\n            .clusterId(resource.upstash_kafka_cluster().exampleKafkaCluster().cluster_id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleKafkaCluster:\n    type: upstash:KafkaCluster\n    properties:\n      clusterName: Terraform_Upstash_Cluster\n      region: eu-west-1\n      multizone: false\n  exampleKafkaTopic:\n    type: upstash:KafkaTopic\n    properties:\n      topicName: TerraformTopic\n      partitions: 1\n      retentionTime: 625135\n      retentionSize: 725124\n      maxMessageSize: 829213\n      cleanupPolicy: delete\n      clusterId: ${resource.upstash_kafka_cluster.exampleKafkaCluster.cluster_id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "cleanupPolicy": {
                    "type": "string",
                    "description": "Cleanup policy will be used in the topic(compact or delete)\n"
                },
                "clusterId": {
                    "type": "string",
                    "description": "ID of the cluster the topic will be deployed in\n"
                },
                "creationTime": {
                    "type": "integer",
                    "description": "Creation time of the topic\n"
                },
                "maxMessageSize": {
                    "type": "integer",
                    "description": "Max message size in the topic\n"
                },
                "multizone": {
                    "type": "boolean",
                    "description": "Whether multizone replication is enabled\n"
                },
                "partitions": {
                    "type": "integer",
                    "description": "The number of partitions the topic will have\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password to be used in authenticating to the cluster\n"
                },
                "region": {
                    "type": "string",
                    "description": "Region of the kafka topic\n"
                },
                "restEndpoint": {
                    "type": "string",
                    "description": "REST Endpoint of the kafka topic\n"
                },
                "retentionSize": {
                    "type": "integer",
                    "description": "Retention size of the messages in the topic\n"
                },
                "retentionTime": {
                    "type": "integer",
                    "description": "Retention time of messages in the topic\n"
                },
                "state": {
                    "type": "string",
                    "description": "State of the kafka topic (active or deleted)\n"
                },
                "tcpEndpoint": {
                    "type": "string",
                    "description": "TCP Endpoint of the kafka topic\n"
                },
                "topicId": {
                    "type": "string",
                    "description": "Unique Cluster ID for created topic\n"
                },
                "topicName": {
                    "type": "string",
                    "description": "Name of the topic\n"
                },
                "username": {
                    "type": "string",
                    "description": "Base64 encoded username to be used in authenticating to the cluster\n"
                }
            },
            "required": [
                "cleanupPolicy",
                "clusterId",
                "creationTime",
                "maxMessageSize",
                "multizone",
                "partitions",
                "password",
                "region",
                "restEndpoint",
                "retentionSize",
                "retentionTime",
                "state",
                "tcpEndpoint",
                "topicId",
                "topicName",
                "username"
            ],
            "inputProperties": {
                "cleanupPolicy": {
                    "type": "string",
                    "description": "Cleanup policy will be used in the topic(compact or delete)\n",
                    "willReplaceOnChanges": true
                },
                "clusterId": {
                    "type": "string",
                    "description": "ID of the cluster the topic will be deployed in\n",
                    "willReplaceOnChanges": true
                },
                "maxMessageSize": {
                    "type": "integer",
                    "description": "Max message size in the topic\n"
                },
                "partitions": {
                    "type": "integer",
                    "description": "The number of partitions the topic will have\n"
                },
                "retentionSize": {
                    "type": "integer",
                    "description": "Retention size of the messages in the topic\n"
                },
                "retentionTime": {
                    "type": "integer",
                    "description": "Retention time of messages in the topic\n"
                },
                "topicName": {
                    "type": "string",
                    "description": "Name of the topic\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "cleanupPolicy",
                "clusterId",
                "maxMessageSize",
                "partitions",
                "retentionSize",
                "retentionTime",
                "topicName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering KafkaTopic resources.\n",
                "properties": {
                    "cleanupPolicy": {
                        "type": "string",
                        "description": "Cleanup policy will be used in the topic(compact or delete)\n",
                        "willReplaceOnChanges": true
                    },
                    "clusterId": {
                        "type": "string",
                        "description": "ID of the cluster the topic will be deployed in\n",
                        "willReplaceOnChanges": true
                    },
                    "creationTime": {
                        "type": "integer",
                        "description": "Creation time of the topic\n"
                    },
                    "maxMessageSize": {
                        "type": "integer",
                        "description": "Max message size in the topic\n"
                    },
                    "multizone": {
                        "type": "boolean",
                        "description": "Whether multizone replication is enabled\n"
                    },
                    "partitions": {
                        "type": "integer",
                        "description": "The number of partitions the topic will have\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password to be used in authenticating to the cluster\n"
                    },
                    "region": {
                        "type": "string",
                        "description": "Region of the kafka topic\n"
                    },
                    "restEndpoint": {
                        "type": "string",
                        "description": "REST Endpoint of the kafka topic\n"
                    },
                    "retentionSize": {
                        "type": "integer",
                        "description": "Retention size of the messages in the topic\n"
                    },
                    "retentionTime": {
                        "type": "integer",
                        "description": "Retention time of messages in the topic\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "State of the kafka topic (active or deleted)\n"
                    },
                    "tcpEndpoint": {
                        "type": "string",
                        "description": "TCP Endpoint of the kafka topic\n"
                    },
                    "topicId": {
                        "type": "string",
                        "description": "Unique Cluster ID for created topic\n"
                    },
                    "topicName": {
                        "type": "string",
                        "description": "Name of the topic\n",
                        "willReplaceOnChanges": true
                    },
                    "username": {
                        "type": "string",
                        "description": "Base64 encoded username to be used in authenticating to the cluster\n"
                    }
                },
                "type": "object"
            }
        },
        "upstash:index/qStashEndpoint:QStashEndpoint": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as pulumi from \"@upstash/pulumi\";\n\nconst exampleQstashEndpoint = new upstash.QStashEndpoint(\"exampleQstashEndpoint\", {\n    url: \"https://***.***\",\n    topicId: resource.upstash_qstash_topic.exampleQstashTopic.topic_id,\n});\n```\n```python\nimport pulumi\nimport upstash_pulumi as upstash\n\nexample_qstash_endpoint = upstash.QStashEndpoint(\"exampleQstashEndpoint\",\n    url=\"https://***.***\",\n    topic_id=resource[\"upstash_qstash_topic\"][\"exampleQstashTopic\"][\"topic_id\"])\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleQstashEndpoint = new Upstash.QStashEndpoint(\"exampleQstashEndpoint\", new Upstash.QStashEndpointArgs\n        {\n            Url = \"https://***.***\",\n            TopicId = resource.Upstash_qstash_topic.ExampleQstashTopic.Topic_id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upstash.NewQStashEndpoint(ctx, \"exampleQstashEndpoint\", \u0026upstash.QStashEndpointArgs{\n\t\t\tUrl:     pulumi.String(\"https://***.***\"),\n\t\t\tTopicId: pulumi.Any(resource.Upstash_qstash_topic.ExampleQstashTopic.Topic_id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleQstashEndpoint = new QStashEndpoint(\"exampleQstashEndpoint\", QStashEndpointArgs.builder()        \n            .url(\"https://***.***\")\n            .topicId(resource.upstash_qstash_topic().exampleQstashTopic().topic_id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleQstashEndpoint:\n    type: upstash:QStashEndpoint\n    properties:\n      url: https://***.***\n      topicId: ${resource.upstash_qstash_topic.exampleQstashTopic.topic_id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "endpointId": {
                    "type": "string",
                    "description": "Unique Qstash Endpoint ID\n"
                },
                "topicId": {
                    "type": "string",
                    "description": "Topic Id that the endpoint is added to\n"
                },
                "topicName": {
                    "type": "string",
                    "description": "Unique Qstash Topic Name for Endpoint\n"
                },
                "url": {
                    "type": "string",
                    "description": "URL of the endpoint\n"
                }
            },
            "required": [
                "endpointId",
                "topicId",
                "topicName",
                "url"
            ],
            "inputProperties": {
                "topicId": {
                    "type": "string",
                    "description": "Topic Id that the endpoint is added to\n",
                    "willReplaceOnChanges": true
                },
                "url": {
                    "type": "string",
                    "description": "URL of the endpoint\n"
                }
            },
            "requiredInputs": [
                "topicId",
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering QStashEndpoint resources.\n",
                "properties": {
                    "endpointId": {
                        "type": "string",
                        "description": "Unique Qstash Endpoint ID\n"
                    },
                    "topicId": {
                        "type": "string",
                        "description": "Topic Id that the endpoint is added to\n",
                        "willReplaceOnChanges": true
                    },
                    "topicName": {
                        "type": "string",
                        "description": "Unique Qstash Topic Name for Endpoint\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "URL of the endpoint\n"
                    }
                },
                "type": "object"
            }
        },
        "upstash:index/qStashSchedule:QStashSchedule": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as pulumi from \"@upstash/pulumi\";\n\nconst exampleQstashSchedule = new upstash.QStashSchedule(\"exampleQstashSchedule\", {\n    destination: resource.upstash_qstash_topic.exampleQstashTopic.topic_id,\n    cron: \"* * * * */2\",\n});\n// or simply provide a link\n// destination = \"https://***.***\"\n```\n```python\nimport pulumi\nimport upstash_pulumi as upstash\n\nexample_qstash_schedule = upstash.QStashSchedule(\"exampleQstashSchedule\",\n    destination=resource[\"upstash_qstash_topic\"][\"exampleQstashTopic\"][\"topic_id\"],\n    cron=\"* * * * */2\")\n# or simply provide a link\n# destination = \"https://***.***\"\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleQstashSchedule = new Upstash.QStashSchedule(\"exampleQstashSchedule\", new Upstash.QStashScheduleArgs\n        {\n            Destination = resource.Upstash_qstash_topic.ExampleQstashTopic.Topic_id,\n            Cron = \"* * * * */2\",\n        });\n        // or simply provide a link\n        // destination = \"https://***.***\"\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upstash.NewQStashSchedule(ctx, \"exampleQstashSchedule\", \u0026upstash.QStashScheduleArgs{\n\t\t\tDestination: pulumi.Any(resource.Upstash_qstash_topic.ExampleQstashTopic.Topic_id),\n\t\t\tCron:        pulumi.String(\"* * * * */2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleQstashSchedule = new QStashSchedule(\"exampleQstashSchedule\", QStashScheduleArgs.builder()        \n            .destination(resource.upstash_qstash_topic().exampleQstashTopic().topic_id())\n            .cron(\"* * * * */2\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleQstashSchedule:\n    type: upstash:QStashSchedule\n    properties:\n      destination: ${resource.upstash_qstash_topic.exampleQstashTopic.topic_id}\n      cron: '* * * * */2'\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "Body to send for the POST request in string format. Needs escaping (\\) double quotes.\n"
                },
                "callback": {
                    "type": "string",
                    "description": "Callback URL for Qstash Schedule.\n"
                },
                "contentBasedDeduplication": {
                    "type": "boolean",
                    "description": "Content Based Deduplication (bool) for Qstash Scheduling.\n"
                },
                "contentType": {
                    "type": "string",
                    "description": "Content type for Qstash Scheduling.\n"
                },
                "createdAt": {
                    "type": "integer",
                    "description": "Creation time for Qstash Schedule.\n"
                },
                "cron": {
                    "type": "string",
                    "description": "Cron string for Qstash Schedule\n"
                },
                "deduplicationId": {
                    "type": "string",
                    "description": "Deduplication ID for Qstash Scheduling.\n"
                },
                "delay": {
                    "type": "string",
                    "description": "Delay for Qstash Schedule.\n"
                },
                "destination": {
                    "type": "string",
                    "description": "Destination for Qstash Schedule. Either Topic ID or valid URL\n"
                },
                "forwardHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Forward headers to your API\n"
                },
                "notBefore": {
                    "type": "integer",
                    "description": "Start time for Qstash Scheduling.\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "Retries for Qstash Schedule requests.\n"
                },
                "scheduleId": {
                    "type": "string",
                    "description": "Unique Qstash Schedule ID for requested schedule\n"
                }
            },
            "required": [
                "createdAt",
                "cron",
                "destination",
                "scheduleId"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "Body to send for the POST request in string format. Needs escaping (\\) double quotes.\n",
                    "willReplaceOnChanges": true
                },
                "callback": {
                    "type": "string",
                    "description": "Callback URL for Qstash Schedule.\n",
                    "willReplaceOnChanges": true
                },
                "contentBasedDeduplication": {
                    "type": "boolean",
                    "description": "Content Based Deduplication (bool) for Qstash Scheduling.\n",
                    "willReplaceOnChanges": true
                },
                "contentType": {
                    "type": "string",
                    "description": "Content type for Qstash Scheduling.\n",
                    "willReplaceOnChanges": true
                },
                "cron": {
                    "type": "string",
                    "description": "Cron string for Qstash Schedule\n",
                    "willReplaceOnChanges": true
                },
                "deduplicationId": {
                    "type": "string",
                    "description": "Deduplication ID for Qstash Scheduling.\n",
                    "willReplaceOnChanges": true
                },
                "delay": {
                    "type": "string",
                    "description": "Delay for Qstash Schedule.\n",
                    "willReplaceOnChanges": true
                },
                "destination": {
                    "type": "string",
                    "description": "Destination for Qstash Schedule. Either Topic ID or valid URL\n",
                    "willReplaceOnChanges": true
                },
                "forwardHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Forward headers to your API\n",
                    "willReplaceOnChanges": true
                },
                "notBefore": {
                    "type": "integer",
                    "description": "Start time for Qstash Scheduling.\n",
                    "willReplaceOnChanges": true
                },
                "retries": {
                    "type": "integer",
                    "description": "Retries for Qstash Schedule requests.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "cron",
                "destination"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering QStashSchedule resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "Body to send for the POST request in string format. Needs escaping (\\) double quotes.\n",
                        "willReplaceOnChanges": true
                    },
                    "callback": {
                        "type": "string",
                        "description": "Callback URL for Qstash Schedule.\n",
                        "willReplaceOnChanges": true
                    },
                    "contentBasedDeduplication": {
                        "type": "boolean",
                        "description": "Content Based Deduplication (bool) for Qstash Scheduling.\n",
                        "willReplaceOnChanges": true
                    },
                    "contentType": {
                        "type": "string",
                        "description": "Content type for Qstash Scheduling.\n",
                        "willReplaceOnChanges": true
                    },
                    "createdAt": {
                        "type": "integer",
                        "description": "Creation time for Qstash Schedule.\n"
                    },
                    "cron": {
                        "type": "string",
                        "description": "Cron string for Qstash Schedule\n",
                        "willReplaceOnChanges": true
                    },
                    "deduplicationId": {
                        "type": "string",
                        "description": "Deduplication ID for Qstash Scheduling.\n",
                        "willReplaceOnChanges": true
                    },
                    "delay": {
                        "type": "string",
                        "description": "Delay for Qstash Schedule.\n",
                        "willReplaceOnChanges": true
                    },
                    "destination": {
                        "type": "string",
                        "description": "Destination for Qstash Schedule. Either Topic ID or valid URL\n",
                        "willReplaceOnChanges": true
                    },
                    "forwardHeaders": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Forward headers to your API\n",
                        "willReplaceOnChanges": true
                    },
                    "notBefore": {
                        "type": "integer",
                        "description": "Start time for Qstash Scheduling.\n",
                        "willReplaceOnChanges": true
                    },
                    "retries": {
                        "type": "integer",
                        "description": "Retries for Qstash Schedule requests.\n",
                        "willReplaceOnChanges": true
                    },
                    "scheduleId": {
                        "type": "string",
                        "description": "Unique Qstash Schedule ID for requested schedule\n"
                    }
                },
                "type": "object"
            }
        },
        "upstash:index/qStashScheduleV2:QStashScheduleV2": {
            "properties": {
                "body": {
                    "type": "string",
                    "description": "Body to send for the POST request in string format. Needs escaping (\\) double quotes.\n"
                },
                "callback": {
                    "type": "string",
                    "description": "Callback URL for Qstash Schedule.\n"
                },
                "contentType": {
                    "type": "string",
                    "description": "Content type for Qstash Scheduling.\n"
                },
                "createdAt": {
                    "type": "integer",
                    "description": "Creation time for Qstash Schedule.\n"
                },
                "cron": {
                    "type": "string",
                    "description": "Cron string for Qstash Schedule\n"
                },
                "delay": {
                    "type": "string",
                    "description": "Delay for Qstash Schedule. Delay should be given in seconds\n"
                },
                "destination": {
                    "type": "string",
                    "description": "Destination for Qstash Schedule. Either Topic Name or valid URL\n"
                },
                "forwardHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Forward headers to your API\n"
                },
                "header": {
                    "type": "string",
                    "description": "Headers for the QStash schedule\n"
                },
                "method": {
                    "type": "string",
                    "description": "Method of Http Request on QStash\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "Retries for Qstash Schedule requests.\n"
                },
                "scheduleId": {
                    "type": "string",
                    "description": "Unique Qstash Schedule ID for requested schedule\n"
                }
            },
            "required": [
                "createdAt",
                "cron",
                "destination",
                "header",
                "scheduleId"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "Body to send for the POST request in string format. Needs escaping (\\) double quotes.\n",
                    "willReplaceOnChanges": true
                },
                "callback": {
                    "type": "string",
                    "description": "Callback URL for Qstash Schedule.\n",
                    "willReplaceOnChanges": true
                },
                "contentType": {
                    "type": "string",
                    "description": "Content type for Qstash Scheduling.\n",
                    "willReplaceOnChanges": true
                },
                "cron": {
                    "type": "string",
                    "description": "Cron string for Qstash Schedule\n",
                    "willReplaceOnChanges": true
                },
                "delay": {
                    "type": "string",
                    "description": "Delay for Qstash Schedule. Delay should be given in seconds\n",
                    "willReplaceOnChanges": true
                },
                "destination": {
                    "type": "string",
                    "description": "Destination for Qstash Schedule. Either Topic Name or valid URL\n",
                    "willReplaceOnChanges": true
                },
                "forwardHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Forward headers to your API\n",
                    "willReplaceOnChanges": true
                },
                "method": {
                    "type": "string",
                    "description": "Method of Http Request on QStash\n",
                    "willReplaceOnChanges": true
                },
                "retries": {
                    "type": "integer",
                    "description": "Retries for Qstash Schedule requests.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "cron",
                "destination"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering QStashScheduleV2 resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "Body to send for the POST request in string format. Needs escaping (\\) double quotes.\n",
                        "willReplaceOnChanges": true
                    },
                    "callback": {
                        "type": "string",
                        "description": "Callback URL for Qstash Schedule.\n",
                        "willReplaceOnChanges": true
                    },
                    "contentType": {
                        "type": "string",
                        "description": "Content type for Qstash Scheduling.\n",
                        "willReplaceOnChanges": true
                    },
                    "createdAt": {
                        "type": "integer",
                        "description": "Creation time for Qstash Schedule.\n"
                    },
                    "cron": {
                        "type": "string",
                        "description": "Cron string for Qstash Schedule\n",
                        "willReplaceOnChanges": true
                    },
                    "delay": {
                        "type": "string",
                        "description": "Delay for Qstash Schedule. Delay should be given in seconds\n",
                        "willReplaceOnChanges": true
                    },
                    "destination": {
                        "type": "string",
                        "description": "Destination for Qstash Schedule. Either Topic Name or valid URL\n",
                        "willReplaceOnChanges": true
                    },
                    "forwardHeaders": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Forward headers to your API\n",
                        "willReplaceOnChanges": true
                    },
                    "header": {
                        "type": "string",
                        "description": "Headers for the QStash schedule\n"
                    },
                    "method": {
                        "type": "string",
                        "description": "Method of Http Request on QStash\n",
                        "willReplaceOnChanges": true
                    },
                    "retries": {
                        "type": "integer",
                        "description": "Retries for Qstash Schedule requests.\n",
                        "willReplaceOnChanges": true
                    },
                    "scheduleId": {
                        "type": "string",
                        "description": "Unique Qstash Schedule ID for requested schedule\n"
                    }
                },
                "type": "object"
            }
        },
        "upstash:index/qStashTopic:QStashTopic": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upstash from \"@pulumi/upstash\";\n\nconst exampleQstashTopic = new upstash.QStashTopic(\"exampleQstashTopic\", {});\n```\n```python\nimport pulumi\nimport upstash_pulumi as upstash\n\nexample_qstash_topic = upstash.QStashTopic(\"exampleQstashTopic\")\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleQstashTopic = new Upstash.QStashTopic(\"exampleQstashTopic\", new Upstash.QStashTopicArgs\n        {\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upstash.NewQStashTopic(ctx, \"exampleQstashTopic\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleQstashTopic = new QStashTopic(\"exampleQstashTopic\");\n\n    }\n}\n```\n```yaml\nresources:\n  exampleQstashTopic:\n    type: upstash:QStashTopic\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "description": "Endpoints for the Qstash Topic\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Qstash Topic\n"
                },
                "topicId": {
                    "type": "string",
                    "description": "Unique Qstash Topic ID for requested topic\n"
                }
            },
            "required": [
                "endpoints",
                "name",
                "topicId"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "Name of the Qstash Topic\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering QStashTopic resources.\n",
                "properties": {
                    "endpoints": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        },
                        "description": "Endpoints for the Qstash Topic\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the Qstash Topic\n"
                    },
                    "topicId": {
                        "type": "string",
                        "description": "Unique Qstash Topic ID for requested topic\n"
                    }
                },
                "type": "object"
            }
        },
        "upstash:index/qStashTopicV2:QStashTopicV2": {
            "properties": {
                "createdAt": {
                    "type": "integer",
                    "description": "Creation time for Qstash Topic.\n"
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Endpoints for the Qstash Topic\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Qstash Topic\n"
                },
                "updatedAt": {
                    "type": "integer",
                    "description": "Last Update time for Qstash Topic.\n"
                }
            },
            "required": [
                "createdAt",
                "endpoints",
                "name",
                "updatedAt"
            ],
            "inputProperties": {
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Endpoints for the Qstash Topic\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Qstash Topic\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "endpoints"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering QStashTopicV2 resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "integer",
                        "description": "Creation time for Qstash Topic.\n"
                    },
                    "endpoints": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Endpoints for the Qstash Topic\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the Qstash Topic\n",
                        "willReplaceOnChanges": true
                    },
                    "updatedAt": {
                        "type": "integer",
                        "description": "Last Update time for Qstash Topic.\n"
                    }
                },
                "type": "object"
            }
        },
        "upstash:index/redisDatabase:RedisDatabase": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upstash from \"@pulumi/upstash\";\n\nconst exampleDB = new upstash.RedisDatabase(\"exampleDB\", {\n    databaseName: \"Terraform DB6\",\n    multizone: true,\n    region: \"eu-west-1\",\n    tls: true,\n});\n```\n```python\nimport pulumi\nimport upstash_pulumi as upstash\n\nexample_db = upstash.RedisDatabase(\"exampleDB\",\n    database_name=\"Terraform DB6\",\n    multizone=True,\n    region=\"eu-west-1\",\n    tls=True)\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleDB = new Upstash.RedisDatabase(\"exampleDB\", new Upstash.RedisDatabaseArgs\n        {\n            DatabaseName = \"Terraform DB6\",\n            Multizone = true,\n            Region = \"eu-west-1\",\n            Tls = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upstash.NewRedisDatabase(ctx, \"exampleDB\", \u0026upstash.RedisDatabaseArgs{\n\t\t\tDatabaseName: pulumi.String(\"Terraform DB6\"),\n\t\t\tMultizone:    pulumi.Bool(true),\n\t\t\tRegion:       pulumi.String(\"eu-west-1\"),\n\t\t\tTls:          pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleDB = new RedisDatabase(\"exampleDB\", RedisDatabaseArgs.builder()        \n            .databaseName(\"Terraform DB6\")\n            .multizone(\"true\")\n            .region(\"eu-west-1\")\n            .tls(\"true\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDB:\n    type: upstash:RedisDatabase\n    properties:\n      databaseName: Terraform DB6\n      multizone: true\n      region: eu-west-1\n      tls: true\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "autoScale": {
                    "type": "boolean",
                    "description": "Upgrade to higher plans automatically when it hits quotas\n"
                },
                "consistent": {
                    "type": "boolean",
                    "description": "When enabled, all writes are synchronously persisted to the disk.\n",
                    "deprecationMessage": "Consistent option is deprecated."
                },
                "creationTime": {
                    "type": "integer",
                    "description": "Creation time of the database\n"
                },
                "databaseId": {
                    "type": "string",
                    "description": "Unique Database ID for created database\n"
                },
                "databaseName": {
                    "type": "string",
                    "description": "Name of the database\n"
                },
                "databaseType": {
                    "type": "string",
                    "description": "Type of the database\n"
                },
                "dbDailyBandwidthLimit": {
                    "type": "integer",
                    "description": "Daily bandwidth limit for the database\n"
                },
                "dbDiskThreshold": {
                    "type": "integer",
                    "description": "Disk threshold for the database\n"
                },
                "dbMaxClients": {
                    "type": "integer",
                    "description": "Max clients for the database\n"
                },
                "dbMaxCommandsPerSecond": {
                    "type": "integer",
                    "description": "Max commands per second for the database\n"
                },
                "dbMaxEntrySize": {
                    "type": "integer",
                    "description": "Max entry size for the database\n"
                },
                "dbMaxRequestSize": {
                    "type": "integer",
                    "description": "Max request size for the database\n"
                },
                "dbMemoryThreshold": {
                    "type": "integer",
                    "description": "Memory threshold for the database\n"
                },
                "endpoint": {
                    "type": "string",
                    "description": "Database URL for connection\n"
                },
                "eviction": {
                    "type": "boolean",
                    "description": "Enable eviction, to evict keys when your database reaches the max size\n"
                },
                "multizone": {
                    "type": "boolean",
                    "description": "When enabled, database becomes highly available and is deployed in multiple zones. (If changed to false from true,\nresults in deletion and recreation of the resource)\n",
                    "deprecationMessage": "Multizone option is deprecated. It is enabled by default for paid databases."
                },
                "password": {
                    "type": "string",
                    "description": "Password of the database\n",
                    "secret": true
                },
                "port": {
                    "type": "integer",
                    "description": "Port of the endpoint\n"
                },
                "primaryRegion": {
                    "type": "string",
                    "description": "Primary region for the database (Only works if region='global'. Can be one of [us-east-1, us-west-1, us-west-2,\neu-central-1, eu-west-1, sa-east-1, ap-southeast-1, ap-southeast-2])\n"
                },
                "readOnlyRestToken": {
                    "type": "string",
                    "description": "Rest Token for the database.\n"
                },
                "readRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Read regions for the database (Only works if region='global' and primary_region is set. Can be any combination of\n[us-east-1, us-west-1, us-west-2, eu-central-1, eu-west-1, sa-east-1, ap-southeast-1, ap-southeast-2], excluding the one\ngiven as primary.)\n"
                },
                "region": {
                    "type": "string",
                    "description": "region of the database. Possible values are: \"global\", \"eu-west-1\", \"us-east-1\", \"us-west-1\", \"ap-northeast-1\" ,\n\"eu-central-1\"\n"
                },
                "restToken": {
                    "type": "string",
                    "description": "Rest Token for the database.\n"
                },
                "state": {
                    "type": "string",
                    "description": "State of the database\n"
                },
                "tls": {
                    "type": "boolean",
                    "description": "When enabled, data is encrypted in transit. (If changed to false from true, results in deletion and recreation of the\nresource)\n"
                },
                "userEmail": {
                    "type": "string",
                    "description": "User email for the database\n"
                }
            },
            "required": [
                "creationTime",
                "databaseId",
                "databaseName",
                "databaseType",
                "dbDailyBandwidthLimit",
                "dbDiskThreshold",
                "dbMaxClients",
                "dbMaxCommandsPerSecond",
                "dbMaxEntrySize",
                "dbMaxRequestSize",
                "dbMemoryThreshold",
                "endpoint",
                "password",
                "port",
                "readOnlyRestToken",
                "region",
                "restToken",
                "state",
                "userEmail"
            ],
            "inputProperties": {
                "autoScale": {
                    "type": "boolean",
                    "description": "Upgrade to higher plans automatically when it hits quotas\n"
                },
                "consistent": {
                    "type": "boolean",
                    "description": "When enabled, all writes are synchronously persisted to the disk.\n",
                    "deprecationMessage": "Consistent option is deprecated."
                },
                "databaseName": {
                    "type": "string",
                    "description": "Name of the database\n",
                    "willReplaceOnChanges": true
                },
                "eviction": {
                    "type": "boolean",
                    "description": "Enable eviction, to evict keys when your database reaches the max size\n"
                },
                "multizone": {
                    "type": "boolean",
                    "description": "When enabled, database becomes highly available and is deployed in multiple zones. (If changed to false from true,\nresults in deletion and recreation of the resource)\n",
                    "deprecationMessage": "Multizone option is deprecated. It is enabled by default for paid databases."
                },
                "primaryRegion": {
                    "type": "string",
                    "description": "Primary region for the database (Only works if region='global'. Can be one of [us-east-1, us-west-1, us-west-2,\neu-central-1, eu-west-1, sa-east-1, ap-southeast-1, ap-southeast-2])\n",
                    "willReplaceOnChanges": true
                },
                "readRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Read regions for the database (Only works if region='global' and primary_region is set. Can be any combination of\n[us-east-1, us-west-1, us-west-2, eu-central-1, eu-west-1, sa-east-1, ap-southeast-1, ap-southeast-2], excluding the one\ngiven as primary.)\n"
                },
                "region": {
                    "type": "string",
                    "description": "region of the database. Possible values are: \"global\", \"eu-west-1\", \"us-east-1\", \"us-west-1\", \"ap-northeast-1\" ,\n\"eu-central-1\"\n",
                    "willReplaceOnChanges": true
                },
                "tls": {
                    "type": "boolean",
                    "description": "When enabled, data is encrypted in transit. (If changed to false from true, results in deletion and recreation of the\nresource)\n"
                }
            },
            "requiredInputs": [
                "databaseName",
                "region"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RedisDatabase resources.\n",
                "properties": {
                    "autoScale": {
                        "type": "boolean",
                        "description": "Upgrade to higher plans automatically when it hits quotas\n"
                    },
                    "consistent": {
                        "type": "boolean",
                        "description": "When enabled, all writes are synchronously persisted to the disk.\n",
                        "deprecationMessage": "Consistent option is deprecated."
                    },
                    "creationTime": {
                        "type": "integer",
                        "description": "Creation time of the database\n"
                    },
                    "databaseId": {
                        "type": "string",
                        "description": "Unique Database ID for created database\n"
                    },
                    "databaseName": {
                        "type": "string",
                        "description": "Name of the database\n",
                        "willReplaceOnChanges": true
                    },
                    "databaseType": {
                        "type": "string",
                        "description": "Type of the database\n"
                    },
                    "dbDailyBandwidthLimit": {
                        "type": "integer",
                        "description": "Daily bandwidth limit for the database\n"
                    },
                    "dbDiskThreshold": {
                        "type": "integer",
                        "description": "Disk threshold for the database\n"
                    },
                    "dbMaxClients": {
                        "type": "integer",
                        "description": "Max clients for the database\n"
                    },
                    "dbMaxCommandsPerSecond": {
                        "type": "integer",
                        "description": "Max commands per second for the database\n"
                    },
                    "dbMaxEntrySize": {
                        "type": "integer",
                        "description": "Max entry size for the database\n"
                    },
                    "dbMaxRequestSize": {
                        "type": "integer",
                        "description": "Max request size for the database\n"
                    },
                    "dbMemoryThreshold": {
                        "type": "integer",
                        "description": "Memory threshold for the database\n"
                    },
                    "endpoint": {
                        "type": "string",
                        "description": "Database URL for connection\n"
                    },
                    "eviction": {
                        "type": "boolean",
                        "description": "Enable eviction, to evict keys when your database reaches the max size\n"
                    },
                    "multizone": {
                        "type": "boolean",
                        "description": "When enabled, database becomes highly available and is deployed in multiple zones. (If changed to false from true,\nresults in deletion and recreation of the resource)\n",
                        "deprecationMessage": "Multizone option is deprecated. It is enabled by default for paid databases."
                    },
                    "password": {
                        "type": "string",
                        "description": "Password of the database\n",
                        "secret": true
                    },
                    "port": {
                        "type": "integer",
                        "description": "Port of the endpoint\n"
                    },
                    "primaryRegion": {
                        "type": "string",
                        "description": "Primary region for the database (Only works if region='global'. Can be one of [us-east-1, us-west-1, us-west-2,\neu-central-1, eu-west-1, sa-east-1, ap-southeast-1, ap-southeast-2])\n",
                        "willReplaceOnChanges": true
                    },
                    "readOnlyRestToken": {
                        "type": "string",
                        "description": "Rest Token for the database.\n"
                    },
                    "readRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Read regions for the database (Only works if region='global' and primary_region is set. Can be any combination of\n[us-east-1, us-west-1, us-west-2, eu-central-1, eu-west-1, sa-east-1, ap-southeast-1, ap-southeast-2], excluding the one\ngiven as primary.)\n"
                    },
                    "region": {
                        "type": "string",
                        "description": "region of the database. Possible values are: \"global\", \"eu-west-1\", \"us-east-1\", \"us-west-1\", \"ap-northeast-1\" ,\n\"eu-central-1\"\n",
                        "willReplaceOnChanges": true
                    },
                    "restToken": {
                        "type": "string",
                        "description": "Rest Token for the database.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "State of the database\n"
                    },
                    "tls": {
                        "type": "boolean",
                        "description": "When enabled, data is encrypted in transit. (If changed to false from true, results in deletion and recreation of the\nresource)\n"
                    },
                    "userEmail": {
                        "type": "string",
                        "description": "User email for the database\n"
                    }
                },
                "type": "object"
            }
        },
        "upstash:index/team:Team": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as pulumi from \"@upstash/pulumi\";\n\nconst exampleTeam = new upstash.Team(\"exampleTeam\", {\n    teamName: \"TerraformTeam\",\n    copyCc: false,\n    teamMembers: {\n        \"X@Y.Z\": \"owner\",\n        \"A@B.C\": \"dev\",\n        \"E@E.F\": \"finance\",\n    },\n});\n```\n```python\nimport pulumi\nimport upstash_pulumi as upstash\n\nexample_team = upstash.Team(\"exampleTeam\",\n    team_name=\"TerraformTeam\",\n    copy_cc=False,\n    team_members={\n        \"X@Y.Z\": \"owner\",\n        \"A@B.C\": \"dev\",\n        \"E@E.F\": \"finance\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleTeam = new Upstash.Team(\"exampleTeam\", new Upstash.TeamArgs\n        {\n            TeamName = \"TerraformTeam\",\n            CopyCc = false,\n            TeamMembers = \n            {\n                { \"X@Y.Z\", \"owner\" },\n                { \"A@B.C\", \"dev\" },\n                { \"E@E.F\", \"finance\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upstash.NewTeam(ctx, \"exampleTeam\", \u0026upstash.TeamArgs{\n\t\t\tTeamName: pulumi.String(\"TerraformTeam\"),\n\t\t\tCopyCc:   pulumi.Bool(false),\n\t\t\tTeamMembers: pulumi.StringMap{\n\t\t\t\t\"X@Y.Z\": pulumi.String(\"owner\"),\n\t\t\t\t\"A@B.C\": pulumi.String(\"dev\"),\n\t\t\t\t\"E@E.F\": pulumi.String(\"finance\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleTeam = new Team(\"exampleTeam\", TeamArgs.builder()        \n            .teamName(\"TerraformTeam\")\n            .copyCc(false)\n            .teamMembers(Map.ofEntries(\n                Map.entry(\"X@Y.Z\", \"owner\"),\n                Map.entry(\"A@B.C\", \"dev\"),\n                Map.entry(\"E@E.F\", \"finance\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleTeam:\n    type: upstash:Team\n    properties:\n      teamName: TerraformTeam\n      copyCc: false\n      teamMembers:\n        X@Y.Z: owner\n        A@B.C: dev\n        E@E.F: finance\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "copyCc": {
                    "type": "boolean",
                    "description": "Whether Credit Card is copied\n"
                },
                "teamId": {
                    "type": "string",
                    "description": "Unique Cluster ID for created cluster\n"
                },
                "teamMembers": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Members of the team. (Owner must be specified, which is the owner of the api key.)\n"
                },
                "teamName": {
                    "type": "string",
                    "description": "Name of the team\n"
                }
            },
            "required": [
                "copyCc",
                "teamId",
                "teamMembers",
                "teamName"
            ],
            "inputProperties": {
                "copyCc": {
                    "type": "boolean",
                    "description": "Whether Credit Card is copied\n",
                    "willReplaceOnChanges": true
                },
                "teamMembers": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Members of the team. (Owner must be specified, which is the owner of the api key.)\n"
                },
                "teamName": {
                    "type": "string",
                    "description": "Name of the team\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "copyCc",
                "teamMembers",
                "teamName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Team resources.\n",
                "properties": {
                    "copyCc": {
                        "type": "boolean",
                        "description": "Whether Credit Card is copied\n",
                        "willReplaceOnChanges": true
                    },
                    "teamId": {
                        "type": "string",
                        "description": "Unique Cluster ID for created cluster\n"
                    },
                    "teamMembers": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Members of the team. (Owner must be specified, which is the owner of the api key.)\n"
                    },
                    "teamName": {
                        "type": "string",
                        "description": "Name of the team\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "upstash:index/vectorIndex:VectorIndex": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upstash from \"@pulumi/upstash\";\n\nconst vectorResource = new upstash.VectorIndex(\"vectorResource\", {\n    dimensionCount: 1536,\n    region: \"us-east-1\",\n    similarityFunction: \"COSINE\",\n    type: \"fixed\",\n});\n```\n```python\nimport pulumi\nimport upstash_pulumi as upstash\n\nvector_resource = upstash.VectorIndex(\"vectorResource\",\n    dimension_count=1536,\n    region=\"us-east-1\",\n    similarity_function=\"COSINE\",\n    type=\"fixed\")\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var vectorResource = new Upstash.VectorIndex(\"vectorResource\", new Upstash.VectorIndexArgs\n        {\n            DimensionCount = 1536,\n            Region = \"us-east-1\",\n            SimilarityFunction = \"COSINE\",\n            Type = \"fixed\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upstash.NewVectorIndex(ctx, \"vectorResource\", \u0026upstash.VectorIndexArgs{\n\t\t\tDimensionCount:     pulumi.Int(1536),\n\t\t\tRegion:             pulumi.String(\"us-east-1\"),\n\t\t\tSimilarityFunction: pulumi.String(\"COSINE\"),\n\t\t\tType:               pulumi.String(\"fixed\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var vectorResource = new VectorIndex(\"vectorResource\", VectorIndexArgs.builder()        \n            .dimensionCount(1536)\n            .region(\"us-east-1\")\n            .similarityFunction(\"COSINE\")\n            .type(\"fixed\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vectorResource:\n    type: upstash:VectorIndex\n    properties:\n      dimensionCount: 1536\n      region: us-east-1\n      similarityFunction: COSINE\n      type: fixed\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "creationTime": {
                    "type": "integer",
                    "description": "The creation time of the vector index in UTC as unix timestamp.\n"
                },
                "customerId": {
                    "type": "string",
                    "description": "The unique ID associated to the owner of this index.\n"
                },
                "dimensionCount": {
                    "type": "integer",
                    "description": "Size of the vector array.\n"
                },
                "endpoint": {
                    "type": "string",
                    "description": "Associated endpoint of your index.\n"
                },
                "maxDailyQueries": {
                    "type": "integer",
                    "description": "The number of maximum query operations you can perform in a day. Only query operations are included in query count.\n"
                },
                "maxDailyUpdates": {
                    "type": "integer",
                    "description": "The number of maximum update operations you can perform in a day. Only upsert operations are included in update count.\n"
                },
                "maxMonthlyBandwidth": {
                    "type": "integer",
                    "description": "The maximum amount of monthly bandwidth for the index. Unit is bytes. `-1` if the limit is unlimited.\n"
                },
                "maxQueryPerSecond": {
                    "type": "integer",
                    "description": "The number of maximum query operations you can perform per second. Only query operations are included in query count.\n"
                },
                "maxReadsPerRequest": {
                    "type": "integer",
                    "description": "The number of maximum vectors in a read operation. Query and fetch operations are included in read operations.\n"
                },
                "maxTotalMetadataSize": {
                    "type": "integer",
                    "description": "The amount of maximum size for the total metadata sizes in your index.\n"
                },
                "maxVectorCount": {
                    "type": "integer",
                    "description": "The number of maximum that your index can contain.\n"
                },
                "maxWritesPerRequest": {
                    "type": "integer",
                    "description": "The number of maximum vectors in a write operation. Only upsert operations are included in write operations.\n"
                },
                "maxWritesPerSecond": {
                    "type": "integer",
                    "description": "The number of maximum write operations you can perform per second. Only upsert operations are included in write count.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the index.\n"
                },
                "readOnlyToken": {
                    "type": "string",
                    "description": "Readonly REST token to send request to the related index. You can't perform update operation with this token.\n"
                },
                "region": {
                    "type": "string",
                    "description": "The region where your index is deployed.\n"
                },
                "reservedPrice": {
                    "type": "number",
                    "description": "Monthly pricing of your index. Only available for fixed and pro plans.\n"
                },
                "similarityFunction": {
                    "type": "string",
                    "description": "Associated distance metric to calculate the similarity.\n"
                },
                "token": {
                    "type": "string",
                    "description": "REST token to send request to the related index.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Associated plan of the index. Either `free`, `paid`, `fixed` or `pro`.\n"
                }
            },
            "required": [
                "creationTime",
                "customerId",
                "dimensionCount",
                "endpoint",
                "maxDailyQueries",
                "maxDailyUpdates",
                "maxMonthlyBandwidth",
                "maxQueryPerSecond",
                "maxReadsPerRequest",
                "maxTotalMetadataSize",
                "maxVectorCount",
                "maxWritesPerRequest",
                "maxWritesPerSecond",
                "name",
                "readOnlyToken",
                "region",
                "reservedPrice",
                "similarityFunction",
                "token",
                "type"
            ],
            "inputProperties": {
                "dimensionCount": {
                    "type": "integer",
                    "description": "Size of the vector array.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the index.\n"
                },
                "region": {
                    "type": "string",
                    "description": "The region where your index is deployed.\n"
                },
                "reservedPrice": {
                    "type": "number",
                    "description": "Monthly pricing of your index. Only available for fixed and pro plans.\n"
                },
                "similarityFunction": {
                    "type": "string",
                    "description": "Associated distance metric to calculate the similarity.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Associated plan of the index. Either `free`, `paid`, `fixed` or `pro`.\n"
                }
            },
            "requiredInputs": [
                "dimensionCount",
                "region",
                "similarityFunction",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VectorIndex resources.\n",
                "properties": {
                    "creationTime": {
                        "type": "integer",
                        "description": "The creation time of the vector index in UTC as unix timestamp.\n"
                    },
                    "customerId": {
                        "type": "string",
                        "description": "The unique ID associated to the owner of this index.\n"
                    },
                    "dimensionCount": {
                        "type": "integer",
                        "description": "Size of the vector array.\n"
                    },
                    "endpoint": {
                        "type": "string",
                        "description": "Associated endpoint of your index.\n"
                    },
                    "maxDailyQueries": {
                        "type": "integer",
                        "description": "The number of maximum query operations you can perform in a day. Only query operations are included in query count.\n"
                    },
                    "maxDailyUpdates": {
                        "type": "integer",
                        "description": "The number of maximum update operations you can perform in a day. Only upsert operations are included in update count.\n"
                    },
                    "maxMonthlyBandwidth": {
                        "type": "integer",
                        "description": "The maximum amount of monthly bandwidth for the index. Unit is bytes. `-1` if the limit is unlimited.\n"
                    },
                    "maxQueryPerSecond": {
                        "type": "integer",
                        "description": "The number of maximum query operations you can perform per second. Only query operations are included in query count.\n"
                    },
                    "maxReadsPerRequest": {
                        "type": "integer",
                        "description": "The number of maximum vectors in a read operation. Query and fetch operations are included in read operations.\n"
                    },
                    "maxTotalMetadataSize": {
                        "type": "integer",
                        "description": "The amount of maximum size for the total metadata sizes in your index.\n"
                    },
                    "maxVectorCount": {
                        "type": "integer",
                        "description": "The number of maximum that your index can contain.\n"
                    },
                    "maxWritesPerRequest": {
                        "type": "integer",
                        "description": "The number of maximum vectors in a write operation. Only upsert operations are included in write operations.\n"
                    },
                    "maxWritesPerSecond": {
                        "type": "integer",
                        "description": "The number of maximum write operations you can perform per second. Only upsert operations are included in write count.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the index.\n"
                    },
                    "readOnlyToken": {
                        "type": "string",
                        "description": "Readonly REST token to send request to the related index. You can't perform update operation with this token.\n"
                    },
                    "region": {
                        "type": "string",
                        "description": "The region where your index is deployed.\n"
                    },
                    "reservedPrice": {
                        "type": "number",
                        "description": "Monthly pricing of your index. Only available for fixed and pro plans.\n"
                    },
                    "similarityFunction": {
                        "type": "string",
                        "description": "Associated distance metric to calculate the similarity.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "REST token to send request to the related index.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Associated plan of the index. Either `free`, `paid`, `fixed` or `pro`.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "upstash:index/getKafkaCluster:getKafkaCluster": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upstash from \"@pulumi/upstash\";\n\nconst clusterData = upstash.getKafkaCluster({\n    clusterId: resource.upstash_kafka_cluster.exampleCluster.cluster_id,\n});\n```\n```python\nimport pulumi\nimport pulumi_upstash as upstash\n\ncluster_data = upstash.get_kafka_cluster(cluster_id=resource[\"upstash_kafka_cluster\"][\"exampleCluster\"][\"cluster_id\"])\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var clusterData = Output.Create(Upstash.GetKafkaCluster.InvokeAsync(new Upstash.GetKafkaClusterArgs\n        {\n            ClusterId = resource.Upstash_kafka_cluster.ExampleCluster.Cluster_id,\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-upstash/sdk/go/upstash\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upstash.LookupKafkaCluster(ctx, \u0026GetKafkaClusterArgs{\n\t\t\tClusterId: resource.Upstash_kafka_cluster.ExampleCluster.Cluster_id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var clusterData = Output.of(UpstashFunctions.getKafkaCluster(GetKafkaClusterArgs.builder()\n            .clusterId(resource.upstash_kafka_cluster().exampleCluster().cluster_id())\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  clusterData:\n    Fn::Invoke:\n      Function: upstash:getKafkaCluster\n      Arguments:\n        clusterId: ${resource.upstash_kafka_cluster.exampleCluster.cluster_id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getKafkaCluster.\n",
                "properties": {
                    "clusterId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getKafkaCluster.\n",
                "properties": {
                    "clusterId": {
                        "type": "string"
                    },
                    "clusterName": {
                        "type": "string"
                    },
                    "creationTime": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "maxMessageSize": {
                        "type": "integer"
                    },
                    "maxMessagesPerSecond": {
                        "type": "integer"
                    },
                    "maxPartitions": {
                        "type": "integer"
                    },
                    "maxRetentionSize": {
                        "type": "integer"
                    },
                    "maxRetentionTime": {
                        "type": "integer"
                    },
                    "multizone": {
                        "type": "boolean"
                    },
                    "password": {
                        "type": "string"
                    },
                    "region": {
                        "type": "string"
                    },
                    "restEndpoint": {
                        "type": "string"
                    },
                    "state": {
                        "type": "string"
                    },
                    "tcpEndpoint": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId",
                    "clusterName",
                    "creationTime",
                    "maxMessageSize",
                    "maxMessagesPerSecond",
                    "maxPartitions",
                    "maxRetentionSize",
                    "maxRetentionTime",
                    "multizone",
                    "password",
                    "region",
                    "restEndpoint",
                    "state",
                    "tcpEndpoint",
                    "type",
                    "username",
                    "id"
                ]
            }
        },
        "upstash:index/getKafkaConnector:getKafkaConnector": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upstash from \"@pulumi/upstash\";\n\nconst kafkaConnectorData = upstash.getKafkaConnector({\n    topicId: resource.upstash_kafka_connector.exampleKafkaConnector.connector_id,\n});\n```\n```python\nimport pulumi\nimport pulumi_upstash as upstash\n\nkafka_connector_data = upstash.get_kafka_connector(topic_id=resource[\"upstash_kafka_connector\"][\"exampleKafkaConnector\"][\"connector_id\"])\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var kafkaConnectorData = Output.Create(Upstash.GetKafkaConnector.InvokeAsync(new Upstash.GetKafkaConnectorArgs\n        {\n            TopicId = resource.Upstash_kafka_connector.ExampleKafkaConnector.Connector_id,\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-upstash/sdk/go/upstash\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upstash.LookupKafkaConnector(ctx, \u0026GetKafkaConnectorArgs{\n\t\t\tTopicId: resource.Upstash_kafka_connector.ExampleKafkaConnector.Connector_id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var kafkaConnectorData = Output.of(UpstashFunctions.getKafkaConnector(GetKafkaConnectorArgs.builder()\n            .topicId(resource.upstash_kafka_connector().exampleKafkaConnector().connector_id())\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  kafkaConnectorData:\n    Fn::Invoke:\n      Function: upstash:getKafkaConnector\n      Arguments:\n        topicId: ${resource.upstash_kafka_connector.exampleKafkaConnector.connector_id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getKafkaConnector.\n",
                "properties": {
                    "connectorId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "connectorId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getKafkaConnector.\n",
                "properties": {
                    "clusterId": {
                        "type": "string"
                    },
                    "connectorClass": {
                        "type": "string"
                    },
                    "connectorId": {
                        "type": "string"
                    },
                    "connectorState": {
                        "type": "string"
                    },
                    "creationTime": {
                        "type": "integer"
                    },
                    "encodedUsername": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "properties": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "propertiesEncrypted": {
                        "type": "string"
                    },
                    "state": {
                        "type": "string"
                    },
                    "stateErrorMessage": {
                        "type": "string"
                    },
                    "tasks": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        }
                    },
                    "topics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "ttl": {
                        "type": "integer"
                    },
                    "userPassword": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId",
                    "connectorClass",
                    "connectorId",
                    "connectorState",
                    "creationTime",
                    "encodedUsername",
                    "name",
                    "properties",
                    "propertiesEncrypted",
                    "state",
                    "stateErrorMessage",
                    "tasks",
                    "topics",
                    "ttl",
                    "userPassword",
                    "id"
                ]
            }
        },
        "upstash:index/getKafkaCredential:getKafkaCredential": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upstash from \"@pulumi/upstash\";\n\nconst kafkaCredentialData = upstash.getKafkaCredential({\n    credentialId: upstash_kafka_credential.exampleKafkaCredential.credential_id,\n});\n```\n```python\nimport pulumi\nimport pulumi_upstash as upstash\n\nkafka_credential_data = upstash.get_kafka_credential(credential_id=upstash_kafka_credential[\"exampleKafkaCredential\"][\"credential_id\"])\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var kafkaCredentialData = Output.Create(Upstash.GetKafkaCredential.InvokeAsync(new Upstash.GetKafkaCredentialArgs\n        {\n            CredentialId = upstash_kafka_credential.ExampleKafkaCredential.Credential_id,\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-upstash/sdk/go/upstash\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upstash.LookupKafkaCredential(ctx, \u0026GetKafkaCredentialArgs{\n\t\t\tCredentialId: upstash_kafka_credential.ExampleKafkaCredential.Credential_id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var kafkaCredentialData = Output.of(UpstashFunctions.getKafkaCredential(GetKafkaCredentialArgs.builder()\n            .credentialId(upstash_kafka_credential.exampleKafkaCredential().credential_id())\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  kafkaCredentialData:\n    Fn::Invoke:\n      Function: upstash:getKafkaCredential\n      Arguments:\n        credentialId: ${upstash_kafka_credential.exampleKafkaCredential.credential_id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getKafkaCredential.\n",
                "properties": {
                    "credentialId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "credentialId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getKafkaCredential.\n",
                "properties": {
                    "clusterId": {
                        "type": "string"
                    },
                    "creationTime": {
                        "type": "integer"
                    },
                    "credentialId": {
                        "type": "string"
                    },
                    "credentialName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "password": {
                        "type": "string"
                    },
                    "permissions": {
                        "type": "string"
                    },
                    "state": {
                        "type": "string"
                    },
                    "topic": {
                        "type": "string"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId",
                    "creationTime",
                    "credentialId",
                    "credentialName",
                    "password",
                    "permissions",
                    "state",
                    "topic",
                    "username",
                    "id"
                ]
            }
        },
        "upstash:index/getKafkaTopic:getKafkaTopic": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upstash from \"@pulumi/upstash\";\n\nconst kafkaTopicData = upstash.getKafkaTopic({\n    topicId: resource.upstash_kafka_topic.exampleKafkaTopic.topic_id,\n});\n```\n```python\nimport pulumi\nimport pulumi_upstash as upstash\n\nkafka_topic_data = upstash.get_kafka_topic(topic_id=resource[\"upstash_kafka_topic\"][\"exampleKafkaTopic\"][\"topic_id\"])\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var kafkaTopicData = Output.Create(Upstash.GetKafkaTopic.InvokeAsync(new Upstash.GetKafkaTopicArgs\n        {\n            TopicId = resource.Upstash_kafka_topic.ExampleKafkaTopic.Topic_id,\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-upstash/sdk/go/upstash\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upstash.LookupKafkaTopic(ctx, \u0026GetKafkaTopicArgs{\n\t\t\tTopicId: resource.Upstash_kafka_topic.ExampleKafkaTopic.Topic_id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var kafkaTopicData = Output.of(UpstashFunctions.getKafkaTopic(GetKafkaTopicArgs.builder()\n            .topicId(resource.upstash_kafka_topic().exampleKafkaTopic().topic_id())\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  kafkaTopicData:\n    Fn::Invoke:\n      Function: upstash:getKafkaTopic\n      Arguments:\n        topicId: ${resource.upstash_kafka_topic.exampleKafkaTopic.topic_id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getKafkaTopic.\n",
                "properties": {
                    "topicId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "topicId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getKafkaTopic.\n",
                "properties": {
                    "cleanupPolicy": {
                        "type": "string"
                    },
                    "clusterId": {
                        "type": "string"
                    },
                    "creationTime": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "maxMessageSize": {
                        "type": "integer"
                    },
                    "multizone": {
                        "type": "boolean"
                    },
                    "partitions": {
                        "type": "integer"
                    },
                    "password": {
                        "type": "string"
                    },
                    "region": {
                        "type": "string"
                    },
                    "restEndpoint": {
                        "type": "string"
                    },
                    "retentionSize": {
                        "type": "integer"
                    },
                    "retentionTime": {
                        "type": "integer"
                    },
                    "state": {
                        "type": "string"
                    },
                    "tcpEndpoint": {
                        "type": "string"
                    },
                    "topicId": {
                        "type": "string"
                    },
                    "topicName": {
                        "type": "string"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "cleanupPolicy",
                    "clusterId",
                    "creationTime",
                    "maxMessageSize",
                    "multizone",
                    "partitions",
                    "password",
                    "region",
                    "restEndpoint",
                    "retentionSize",
                    "retentionTime",
                    "state",
                    "tcpEndpoint",
                    "topicId",
                    "topicName",
                    "username",
                    "id"
                ]
            }
        },
        "upstash:index/getQStashEndpoint:getQStashEndpoint": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upstash from \"@pulumi/upstash\";\n\nconst exampleQstashEndpointData = upstash.getQStashEndpoint({\n    endpointId: resource.upstash_qstash_endpoint.exampleQstashEndpoint.endpoint_id,\n});\n```\n```python\nimport pulumi\nimport pulumi_upstash as upstash\n\nexample_qstash_endpoint_data = upstash.get_q_stash_endpoint(endpoint_id=resource[\"upstash_qstash_endpoint\"][\"exampleQstashEndpoint\"][\"endpoint_id\"])\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleQstashEndpointData = Output.Create(Upstash.GetQStashEndpoint.InvokeAsync(new Upstash.GetQStashEndpointArgs\n        {\n            EndpointId = resource.Upstash_qstash_endpoint.ExampleQstashEndpoint.Endpoint_id,\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-upstash/sdk/go/upstash\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upstash.LookupQStashEndpoint(ctx, \u0026GetQStashEndpointArgs{\n\t\t\tEndpointId: resource.Upstash_qstash_endpoint.ExampleQstashEndpoint.Endpoint_id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var exampleQstashEndpointData = Output.of(UpstashFunctions.getQStashEndpoint(GetQStashEndpointArgs.builder()\n            .endpointId(resource.upstash_qstash_endpoint().exampleQstashEndpoint().endpoint_id())\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  exampleQstashEndpointData:\n    Fn::Invoke:\n      Function: upstash:getQStashEndpoint\n      Arguments:\n        endpointId: ${resource.upstash_qstash_endpoint.exampleQstashEndpoint.endpoint_id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getQStashEndpoint.\n",
                "properties": {
                    "topicId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "topicId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getQStashEndpoint.\n",
                "properties": {
                    "endpointId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "topicId": {
                        "type": "string"
                    },
                    "url": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "endpointId",
                    "topicId",
                    "url",
                    "id"
                ]
            }
        },
        "upstash:index/getQStashSchedule:getQStashSchedule": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upstash from \"@pulumi/upstash\";\n\nconst exampleQstashScheduleData = upstash.getQStashSchedule({\n    scheduleId: resource.upstash_qstash_schedule.exampleQstashSchedule.schedule_id,\n});\n```\n```python\nimport pulumi\nimport pulumi_upstash as upstash\n\nexample_qstash_schedule_data = upstash.get_q_stash_schedule(schedule_id=resource[\"upstash_qstash_schedule\"][\"exampleQstashSchedule\"][\"schedule_id\"])\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleQstashScheduleData = Output.Create(Upstash.GetQStashSchedule.InvokeAsync(new Upstash.GetQStashScheduleArgs\n        {\n            ScheduleId = resource.Upstash_qstash_schedule.ExampleQstashSchedule.Schedule_id,\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-upstash/sdk/go/upstash\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upstash.LookupQStashSchedule(ctx, \u0026GetQStashScheduleArgs{\n\t\t\tScheduleId: resource.Upstash_qstash_schedule.ExampleQstashSchedule.Schedule_id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var exampleQstashScheduleData = Output.of(UpstashFunctions.getQStashSchedule(GetQStashScheduleArgs.builder()\n            .scheduleId(resource.upstash_qstash_schedule().exampleQstashSchedule().schedule_id())\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  exampleQstashScheduleData:\n    Fn::Invoke:\n      Function: upstash:getQStashSchedule\n      Arguments:\n        scheduleId: ${resource.upstash_qstash_schedule.exampleQstashSchedule.schedule_id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getQStashSchedule.\n",
                "properties": {
                    "scheduleId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "scheduleId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getQStashSchedule.\n",
                "properties": {
                    "body": {
                        "type": "string"
                    },
                    "createdAt": {
                        "type": "integer"
                    },
                    "cron": {
                        "type": "string"
                    },
                    "destination": {
                        "type": "string"
                    },
                    "forwardHeaders": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "notBefore": {
                        "type": "integer"
                    },
                    "retries": {
                        "type": "integer"
                    },
                    "scheduleId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "body",
                    "createdAt",
                    "cron",
                    "destination",
                    "forwardHeaders",
                    "notBefore",
                    "retries",
                    "scheduleId",
                    "id"
                ]
            }
        },
        "upstash:index/getQStashScheduleV2:getQStashScheduleV2": {
            "inputs": {
                "description": "A collection of arguments for invoking getQStashScheduleV2.\n",
                "properties": {
                    "body": {
                        "type": "string"
                    },
                    "callback": {
                        "type": "string"
                    },
                    "delay": {
                        "type": "string"
                    },
                    "header": {
                        "type": "string"
                    },
                    "retries": {
                        "type": "integer"
                    },
                    "scheduleId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "scheduleId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getQStashScheduleV2.\n",
                "properties": {
                    "body": {
                        "type": "string"
                    },
                    "callback": {
                        "type": "string"
                    },
                    "createdAt": {
                        "type": "integer"
                    },
                    "cron": {
                        "type": "string"
                    },
                    "delay": {
                        "type": "string"
                    },
                    "destination": {
                        "type": "string"
                    },
                    "header": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "method": {
                        "type": "string"
                    },
                    "retries": {
                        "type": "integer"
                    },
                    "scheduleId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "createdAt",
                    "cron",
                    "destination",
                    "method",
                    "scheduleId",
                    "id"
                ]
            }
        },
        "upstash:index/getQStashTopic:getQStashTopic": {
            "inputs": {
                "description": "A collection of arguments for invoking getQStashTopic.\n",
                "properties": {
                    "topicId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "topicId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getQStashTopic.\n",
                "properties": {
                    "endpoints": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "topicId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "endpoints",
                    "name",
                    "topicId",
                    "id"
                ]
            }
        },
        "upstash:index/getQStashTopicV2:getQStashTopicV2": {
            "inputs": {
                "description": "A collection of arguments for invoking getQStashTopicV2.\n",
                "properties": {
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getQStashTopicV2.\n",
                "properties": {
                    "createdAt": {
                        "type": "integer"
                    },
                    "endpoints": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "updatedAt": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "createdAt",
                    "endpoints",
                    "name",
                    "updatedAt",
                    "id"
                ]
            }
        },
        "upstash:index/getRedisDatabase:getRedisDatabase": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upstash from \"@pulumi/upstash\";\n\nconst exampleDBData = upstash.getRedisDatabase({\n    databaseId: resource.upstash_redis_database.exampleDB.database_id,\n});\n```\n```python\nimport pulumi\nimport pulumi_upstash as upstash\n\nexample_db_data = upstash.get_redis_database(database_id=resource[\"upstash_redis_database\"][\"exampleDB\"][\"database_id\"])\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleDBData = Output.Create(Upstash.GetRedisDatabase.InvokeAsync(new Upstash.GetRedisDatabaseArgs\n        {\n            DatabaseId = resource.Upstash_redis_database.ExampleDB.Database_id,\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-upstash/sdk/go/upstash\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upstash.LookupRedisDatabase(ctx, \u0026GetRedisDatabaseArgs{\n\t\t\tDatabaseId: resource.Upstash_redis_database.ExampleDB.Database_id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var exampleDBData = Output.of(UpstashFunctions.getRedisDatabase(GetRedisDatabaseArgs.builder()\n            .databaseId(resource.upstash_redis_database().exampleDB().database_id())\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  exampleDBData:\n    Fn::Invoke:\n      Function: upstash:getRedisDatabase\n      Arguments:\n        databaseId: ${resource.upstash_redis_database.exampleDB.database_id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getRedisDatabase.\n",
                "properties": {
                    "databaseId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "databaseId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRedisDatabase.\n",
                "properties": {
                    "autoScale": {
                        "type": "boolean"
                    },
                    "consistent": {
                        "type": "boolean",
                        "deprecationMessage": "Consistent option is deprecated."
                    },
                    "creationTime": {
                        "type": "integer"
                    },
                    "databaseId": {
                        "type": "string"
                    },
                    "databaseName": {
                        "type": "string"
                    },
                    "databaseType": {
                        "type": "string"
                    },
                    "dbDailyBandwidthLimit": {
                        "type": "integer"
                    },
                    "dbDiskThreshold": {
                        "type": "integer"
                    },
                    "dbMaxClients": {
                        "type": "integer"
                    },
                    "dbMaxCommandsPerSecond": {
                        "type": "integer"
                    },
                    "dbMaxEntrySize": {
                        "type": "integer"
                    },
                    "dbMaxRequestSize": {
                        "type": "integer"
                    },
                    "dbMemoryThreshold": {
                        "type": "integer"
                    },
                    "endpoint": {
                        "type": "string"
                    },
                    "eviction": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "multizone": {
                        "type": "boolean",
                        "deprecationMessage": "Multizone option is deprecated. It is enabled by default for paid databases."
                    },
                    "password": {
                        "type": "string"
                    },
                    "port": {
                        "type": "integer"
                    },
                    "primaryRegion": {
                        "type": "string"
                    },
                    "readOnlyRestToken": {
                        "type": "string"
                    },
                    "readRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "region": {
                        "type": "string"
                    },
                    "restToken": {
                        "type": "string"
                    },
                    "state": {
                        "type": "string"
                    },
                    "tls": {
                        "type": "boolean"
                    },
                    "userEmail": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "autoScale",
                    "consistent",
                    "creationTime",
                    "databaseId",
                    "databaseName",
                    "databaseType",
                    "dbDailyBandwidthLimit",
                    "dbDiskThreshold",
                    "dbMaxClients",
                    "dbMaxCommandsPerSecond",
                    "dbMaxEntrySize",
                    "dbMaxRequestSize",
                    "dbMemoryThreshold",
                    "endpoint",
                    "eviction",
                    "multizone",
                    "password",
                    "port",
                    "primaryRegion",
                    "readOnlyRestToken",
                    "readRegions",
                    "region",
                    "restToken",
                    "state",
                    "tls",
                    "userEmail",
                    "id"
                ]
            }
        },
        "upstash:index/getTeam:getTeam": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upstash from \"@pulumi/upstash\";\n\nconst teamData = upstash.getTeam({\n    teamId: resource.upstash_team.exampleTeam.team_id,\n});\n```\n```python\nimport pulumi\nimport pulumi_upstash as upstash\n\nteam_data = upstash.get_team(team_id=resource[\"upstash_team\"][\"exampleTeam\"][\"team_id\"])\n```\n```csharp\nusing Pulumi;\nusing Upstash = Pulumi.Upstash;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var teamData = Output.Create(Upstash.GetTeam.InvokeAsync(new Upstash.GetTeamArgs\n        {\n            TeamId = resource.Upstash_team.ExampleTeam.Team_id,\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-upstash/sdk/go/upstash\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/upstash/pulumi-upstash/sdk/go/upstash\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upstash.LookupTeam(ctx, \u0026GetTeamArgs{\n\t\t\tTeamId: resource.Upstash_team.ExampleTeam.Team_id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var teamData = Output.of(UpstashFunctions.getTeam(GetTeamArgs.builder()\n            .teamId(resource.upstash_team().exampleTeam().team_id())\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  teamData:\n    Fn::Invoke:\n      Function: upstash:getTeam\n      Arguments:\n        teamId: ${resource.upstash_team.exampleTeam.team_id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getTeam.\n",
                "properties": {
                    "teamId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "teamId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTeam.\n",
                "properties": {
                    "copyCc": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "teamId": {
                        "type": "string"
                    },
                    "teamMembers": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "teamName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "copyCc",
                    "teamId",
                    "teamMembers",
                    "teamName",
                    "id"
                ]
            }
        },
        "upstash:index/getVectorIndex:getVectorIndex": {
            "inputs": {
                "description": "A collection of arguments for invoking getVectorIndex.\n",
                "properties": {
                    "id": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "id"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVectorIndex.\n",
                "properties": {
                    "creationTime": {
                        "type": "integer"
                    },
                    "customerId": {
                        "type": "string"
                    },
                    "dimensionCount": {
                        "type": "integer"
                    },
                    "endpoint": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "maxDailyQueries": {
                        "type": "integer"
                    },
                    "maxDailyUpdates": {
                        "type": "integer"
                    },
                    "maxMonthlyBandwidth": {
                        "type": "integer"
                    },
                    "maxQueryPerSecond": {
                        "type": "integer"
                    },
                    "maxReadsPerRequest": {
                        "type": "integer"
                    },
                    "maxTotalMetadataSize": {
                        "type": "integer"
                    },
                    "maxVectorCount": {
                        "type": "integer"
                    },
                    "maxWritesPerRequest": {
                        "type": "integer"
                    },
                    "maxWritesPerSecond": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string"
                    },
                    "readOnlyToken": {
                        "type": "string"
                    },
                    "region": {
                        "type": "string"
                    },
                    "reservedPrice": {
                        "type": "number"
                    },
                    "similarityFunction": {
                        "type": "string"
                    },
                    "token": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "creationTime",
                    "customerId",
                    "dimensionCount",
                    "endpoint",
                    "id",
                    "maxDailyQueries",
                    "maxDailyUpdates",
                    "maxMonthlyBandwidth",
                    "maxQueryPerSecond",
                    "maxReadsPerRequest",
                    "maxTotalMetadataSize",
                    "maxVectorCount",
                    "maxWritesPerRequest",
                    "maxWritesPerSecond",
                    "name",
                    "readOnlyToken",
                    "region",
                    "reservedPrice",
                    "similarityFunction",
                    "token",
                    "type"
                ]
            }
        }
    },
    "language": {
        "csharp": {
            "compatibility": "tfbridge20",
            "namespaces": null,
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "rootNamespace": "Pulumi"
        },
        "go": {
            "generateExtraInputTypes": true,
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/upstash/pulumi-upstash/sdk/go/upstash"
        },
        "nodejs": {
            "compatibility": "tfbridge20",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing upstash cloud resources.",
            "packageName": "@upstash/pulumi",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/upstash/terraform-provider-upstash)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-upstash` repo](https://github.com/pulumi/pulumi-upstash/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`upstash/terraform-provider-upstash` repo](https://github.com/upstash/terraform-provider-upstash/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "compatibility": "tfbridge20",
            "packageName": "upstash_pulumi",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/upstash/terraform-provider-upstash)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-upstash` repo](https://github.com/pulumi/pulumi-upstash/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`upstash/terraform-provider-upstash` repo](https://github.com/upstash/terraform-provider-upstash/issues).",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            }
        }
    }
}